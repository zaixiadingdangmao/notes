<body>
  <div id="div1"></div>
  <div id="div2"></div>
</body>

<!-- <script>
  // 1
  function effect() {
    document.body.innerHTML = 'hello vue3';
  }
</script> -->

<!-- <script>
  // 2
  const bucket = new Set();

  const data = { text: '' };

  const obj = new Proxy(data, {
    get(target, key) {
      bucket.add(effect);
      return target[key]
    },

    set(target, key, newValue) {
      target[key] = newValue
      bucket.forEach(fn => fn());

      return true
    }
  })


  function effect() {
    document.body.innerHTML = obj.text
  }

  effect()


  setTimeout(() => {
    obj.text = 'hello vue3'
  }, 1000);
</script> -->

<!-- <script>
  // 3
  const bucket = new WeakMap();
  const data = { text1: '', text2: '' };

  const obj = new Proxy(data, {
    get(target, key) {
      track(target, key);

      return target[key];
    },

    set(target, key, newValue) {
      // è®¾ç½®å±æ€§
      target[key] = newValue;

      trigger(target, key);
      return true;
    }
  });

  // åœ¨ get å†…éƒ¨è·Ÿè¸ªå˜åŒ–
  function track(target, key) {
    if (!activeEffect) return target[key];

    // æ ¹æ® target ä»â€œæ¡¶â€ä¸­å–çš„ depsMapï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª Map ç±»å‹ï¼š key -> effects
    let depsMap = bucket.get(target);
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()));
    }

    // å†æ ¹æ® key ä» depsMap ä¸­å–å¾— depsï¼Œå®ƒæ˜¯ä¸€ä¸ª Set ç±»å‹
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }

    // æœ€åå°†å½“å‰æ¿€æ´»çš„å‡½æ•°æ·»åŠ åˆ°â€œæ¡¶â€ä¸­
    deps.add(activeEffect);
  }

  // åœ¨ set å†…éƒ¨è§¦å‘å˜åŒ–
  function trigger(target, key) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;

    const effects = depsMap.get(key);

    effects && effects.forEach(fn => fn());
  }

  // ç”¨ä¸€ä¸ªå…¨å±€å˜é‡å­˜æ”¾è¢«æ³¨å†Œçš„å‰¯ä½œç”¨å‡½æ•°
  let activeEffect;

  // effect ç”¨æ¥æ³¨å†Œå‰¯ä½œç”¨å‡½æ•°
  function effect(fn) {
    // ä¿å­˜å‰¯ä½œç”¨å‡½æ•°
    const effectFn = () => {
      activeEffect = effectFn;
      fn();
    };

    effectFn();
  }

  effect(() => {
    console.log('ğŸš€  -> file: index.html -> line 113 -> obj.text1');
    document.querySelector('#div1').innerHTML = obj.text1;
  });

  effect(() => {
    console.log('ğŸš€  -> file: index.html -> line 109 -> obj.text2');
    document.querySelector('#div2').innerHTML = obj.text2;
  });
</script> -->

<!-- <script>
  // 4
  // å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶
  const bucket = new WeakMap();

  // åŸå§‹æ•°æ®
  // const data = { ok: true, text: 'hello world' };
  const data = { text1: '', text2: '' };

  // å¯¹åŸå§‹æ•°æ®çš„ä»£ç†
  const obj = new Proxy(data, {
    // æ‹¦æˆªè¯»å–æ“ä½œ
    get(target, key) {
      // å°†å‰¯ä½œç”¨å‡½æ•° activeEffect æ·»åŠ åˆ°å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶ä¸­
      track(target, key);
      // è¿”å›å±æ€§å€¼
      return target[key];
    },
    // æ‹¦æˆªè®¾ç½®æ“ä½œ
    set(target, key, newVal) {
      // è®¾ç½®å±æ€§å€¼
      target[key] = newVal;
      // æŠŠå‰¯ä½œç”¨å‡½æ•°ä»æ¡¶é‡Œå–å‡ºå¹¶æ‰§è¡Œ
      trigger(target, key);
    }
  });

  // åœ¨ get å†…éƒ¨è·Ÿè¸ªå˜åŒ–
  function track(target, key) {
    if (!activeEffect) return target[key];

    // æ ¹æ® target ä»â€œæ¡¶â€ä¸­å–çš„ depsMapï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª Map ç±»å‹ï¼š key -> effects
    let depsMap = bucket.get(target);
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()));
    }

    // å†æ ¹æ® key ä» depsMap ä¸­å–å¾— depsï¼Œå®ƒæ˜¯ä¸€ä¸ª Set ç±»å‹
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }

    // æœ€åå°†å½“å‰æ¿€æ´»çš„å‡½æ•°æ·»åŠ åˆ°â€œæ¡¶â€ä¸­
    deps.add(activeEffect);

    // å°†å…¶æ·»åŠ åˆ° activeEffect.deps æ•°ç»„ä¸­
    activeEffect.deps.push(deps);
  }

  // åœ¨ set å†…éƒ¨è§¦å‘å˜åŒ–
  function trigger(target, key) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;

    const effects = depsMap.get(key);

    const effectsToRun = new Set(effects);
    // effects && effects.forEach(fn => fn());
    effects && effectsToRun.forEach(fn => fn());
  }

  // ç”¨ä¸€ä¸ªå…¨å±€å˜é‡å­˜æ”¾è¢«æ³¨å†Œçš„å‰¯ä½œç”¨å‡½æ•°
  let activeEffect;
  // effect ç”¨æ¥æ³¨å†Œå‰¯ä½œç”¨å‡½æ•°
  function effect(fn) {
    const effectFn = () => {
      cleanup(effectFn);
      // ä¿å­˜å‰¯ä½œç”¨å‡½æ•°
      activeEffect = effectFn;

      fn();
    };

    effectFn.deps = [];

    effectFn();
  }

  function cleanup(effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
      const deps = effectFn.deps[i];
      deps.delete(effectFn);
    }

    effectFn.deps.length = 0;
  }

  effect(() => {
    console.log('effect run');
    document.body.innerText = obj.ok ? obj.text : 'not';
  });

  setTimeout(() => {
    obj.ok = false;
    setTimeout(() => {
      obj.text = 'hello vue3';
    }, 1000);
  }, 1000);
</script> -->

<!-- <script>
  // 5
  // å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶
  const bucket = new WeakMap();

  // åŸå§‹æ•°æ®
  const data = { foo: true, bar: true };

  // å¯¹åŸå§‹æ•°æ®çš„ä»£ç†
  const obj = new Proxy(data, {
    // æ‹¦æˆªè¯»å–æ“ä½œ
    get(target, key) {
      // å°†å‰¯ä½œç”¨å‡½æ•° activeEffect æ·»åŠ åˆ°å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶ä¸­
      track(target, key);
      // è¿”å›å±æ€§å€¼
      return target[key];
    },
    // æ‹¦æˆªè®¾ç½®æ“ä½œ
    set(target, key, newVal) {
      // è®¾ç½®å±æ€§å€¼
      target[key] = newVal;
      // æŠŠå‰¯ä½œç”¨å‡½æ•°ä»æ¡¶é‡Œå–å‡ºå¹¶æ‰§è¡Œ
      trigger(target, key);
    }
  });

  // åœ¨ get å†…éƒ¨è·Ÿè¸ªå˜åŒ–
  function track(target, key) {
    if (!activeEffect) return target[key];

    // æ ¹æ® target ä»â€œæ¡¶â€ä¸­å–çš„ depsMapï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª Map ç±»å‹ï¼š key -> effects
    let depsMap = bucket.get(target);
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()));
    }

    // å†æ ¹æ® key ä» depsMap ä¸­å–å¾— depsï¼Œå®ƒæ˜¯ä¸€ä¸ª Set ç±»å‹
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }

    // æœ€åå°†å½“å‰æ¿€æ´»çš„å‡½æ•°æ·»åŠ åˆ°â€œæ¡¶â€ä¸­
    deps.add(activeEffect);

    // å°†å…¶æ·»åŠ åˆ° activeEffect.deps æ•°ç»„ä¸­
    activeEffect.deps.push(deps);
  }

  // åœ¨ set å†…éƒ¨è§¦å‘å˜åŒ–
  function trigger(target, key) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;

    const effects = depsMap.get(key);

    const effectsToRun = new Set(effects);
    // effects && effects.forEach(fn => fn());
    effects && effectsToRun.forEach(fn => fn());
  }

  // ç”¨ä¸€ä¸ªå…¨å±€å˜é‡å­˜æ”¾è¢«æ³¨å†Œçš„å‰¯ä½œç”¨å‡½æ•°
  let activeEffect;
  // å‰¯ä½œç”¨å‡½æ•°æ ˆ
  const effectStack = [];
  // effect ç”¨æ¥æ³¨å†Œå‰¯ä½œç”¨å‡½æ•°
  function effect(fn) {
    const effectFn = () => {
      cleanup(effectFn);
      // ä¿å­˜å‰¯ä½œç”¨å‡½æ•°
      activeEffect = effectFn;
      // å…¥æ ˆ
      effectStack.push(effectFn);
      fn();
      // å½“å‰å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œå°†å½“å‰å‰¯ä½œç”¨å‡½æ•°å¼¹å‡ºæ ˆï¼Œå¹¶æŠŠ activeEffect å¤åŸå›ä¹‹å‰çš„å€¼
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];
    };
    effectFn.deps = [];
    effectFn();
  }

  function cleanup(effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
      const deps = effectFn.deps[i];
      deps.delete(effectFn);
    }

    effectFn.deps.length = 0;
  }

  let temp1, temp2;

  effect(function effectFn1() {
    console.log('effectFn1 æ‰§è¡Œ');
    effect(function effectFn2() {
      console.log('effectFn2 æ‰§è¡Œ');
      temp2 = obj.bar;
    });
    temp1 = obj.foo;
  });
</script> -->

<!-- <script>
  // å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶
  const bucket = new WeakMap();

  // åŸå§‹æ•°æ®
  const data = { foo: 1 };

  // å¯¹åŸå§‹æ•°æ®çš„ä»£ç†
  const obj = new Proxy(data, {
    // æ‹¦æˆªè¯»å–æ“ä½œ
    get(target, key) {
      // å°†å‰¯ä½œç”¨å‡½æ•° activeEffect æ·»åŠ åˆ°å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶ä¸­
      track(target, key);
      // è¿”å›å±æ€§å€¼
      return target[key];
    },
    // æ‹¦æˆªè®¾ç½®æ“ä½œ
    set(target, key, newVal) {
      // è®¾ç½®å±æ€§å€¼
      target[key] = newVal;
      // æŠŠå‰¯ä½œç”¨å‡½æ•°ä»æ¡¶é‡Œå–å‡ºå¹¶æ‰§è¡Œ
      trigger(target, key);
    }
  });

  // åœ¨ get å†…éƒ¨è·Ÿè¸ªå˜åŒ–
  function track(target, key) {
    if (!activeEffect) return target[key];

    // æ ¹æ® target ä»â€œæ¡¶â€ä¸­å–çš„ depsMapï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª Map ç±»å‹ï¼š key -> effects
    let depsMap = bucket.get(target);
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()));
    }

    // å†æ ¹æ® key ä» depsMap ä¸­å–å¾— depsï¼Œå®ƒæ˜¯ä¸€ä¸ª Set ç±»å‹
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }

    // æœ€åå°†å½“å‰æ¿€æ´»çš„å‡½æ•°æ·»åŠ åˆ°â€œæ¡¶â€ä¸­
    deps.add(activeEffect);

    // å°†å…¶æ·»åŠ åˆ° activeEffect.deps æ•°ç»„ä¸­
    activeEffect.deps.push(deps);
  }

  // åœ¨ set å†…éƒ¨è§¦å‘å˜åŒ–
  function trigger(target, key) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;

    const effects = depsMap.get(key);

    const effectsToRun = new Set();

    effects.forEach(effectFn => {
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn);
      }
    });
    effectsToRun && effectsToRun.forEach(fn => fn());
  }

  // ç”¨ä¸€ä¸ªå…¨å±€å˜é‡å­˜æ”¾è¢«æ³¨å†Œçš„å‰¯ä½œç”¨å‡½æ•°
  let activeEffect;
  // å‰¯ä½œç”¨å‡½æ•°æ ˆ
  const effectStack = [];
  // effect ç”¨æ¥æ³¨å†Œå‰¯ä½œç”¨å‡½æ•°
  function effect(fn) {
    const effectFn = () => {
      cleanup(effectFn);
      // ä¿å­˜å‰¯ä½œç”¨å‡½æ•°
      activeEffect = effectFn;
      // å…¥æ ˆ
      effectStack.push(effectFn);
      fn();
      // å½“å‰å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œå°†å½“å‰å‰¯ä½œç”¨å‡½æ•°å¼¹å‡ºæ ˆï¼Œå¹¶æŠŠ activeEffect å¤åŸå›ä¹‹å‰çš„å€¼
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];
    };
    effectFn.deps = [];
    effectFn();
  }

  function cleanup(effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
      const deps = effectFn.deps[i];
      deps.delete(effectFn);
    }

    effectFn.deps.length = 0;
  }

  effect(function effectFn1() {
    console.log('effectFn1 æ‰§è¡Œ');
    obj.foo++;
  });
</script> -->

<!-- <script>
  // 7

  // å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶
  const bucket = new WeakMap();

  // åŸå§‹æ•°æ®
  const data = { foo: 1 };

  // å¯¹åŸå§‹æ•°æ®çš„ä»£ç†
  const obj = new Proxy(data, {
    // æ‹¦æˆªè¯»å–æ“ä½œ
    get(target, key) {
      // å°†å‰¯ä½œç”¨å‡½æ•° activeEffect æ·»åŠ åˆ°å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶ä¸­
      track(target, key);
      // è¿”å›å±æ€§å€¼
      return target[key];
    },
    // æ‹¦æˆªè®¾ç½®æ“ä½œ
    set(target, key, newVal) {
      // è®¾ç½®å±æ€§å€¼
      target[key] = newVal;
      // æŠŠå‰¯ä½œç”¨å‡½æ•°ä»æ¡¶é‡Œå–å‡ºå¹¶æ‰§è¡Œ
      trigger(target, key);
    }
  });

  // åœ¨ get å†…éƒ¨è·Ÿè¸ªå˜åŒ–
  function track(target, key) {
    if (!activeEffect) return target[key];

    // æ ¹æ® target ä»â€œæ¡¶â€ä¸­å–çš„ depsMapï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª Map ç±»å‹ï¼š key -> effects
    let depsMap = bucket.get(target);
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()));
    }

    // å†æ ¹æ® key ä» depsMap ä¸­å–å¾— depsï¼Œå®ƒæ˜¯ä¸€ä¸ª Set ç±»å‹
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }

    // æœ€åå°†å½“å‰æ¿€æ´»çš„å‡½æ•°æ·»åŠ åˆ°â€œæ¡¶â€ä¸­
    deps.add(activeEffect);

    // å°†å…¶æ·»åŠ åˆ° activeEffect.deps æ•°ç»„ä¸­
    activeEffect.deps.push(deps);
  }

  // åœ¨ set å†…éƒ¨è§¦å‘å˜åŒ–
  function trigger(target, key) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;

    const effects = depsMap.get(key);

    const effectsToRun = new Set();

    effects.forEach(effectFn => {
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn);
      }
    });

    effectsToRun.forEach(effectFn => {
      if (effectFn.options.scheduler) {
        effectFn.options.scheduler(effectFn);
      } else {
        effectFn();
      }
    });
  }

  // ç”¨ä¸€ä¸ªå…¨å±€å˜é‡å­˜æ”¾è¢«æ³¨å†Œçš„å‰¯ä½œç”¨å‡½æ•°
  let activeEffect;
  // å‰¯ä½œç”¨å‡½æ•°æ ˆ
  const effectStack = [];
  // effect ç”¨æ¥æ³¨å†Œå‰¯ä½œç”¨å‡½æ•°
  function effect(fn, options = {}) {
    const effectFn = () => {
      cleanup(effectFn);
      // ä¿å­˜å‰¯ä½œç”¨å‡½æ•°
      activeEffect = effectFn;
      // å…¥æ ˆ
      effectStack.push(effectFn);
      fn();
      // å½“å‰å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œå°†å½“å‰å‰¯ä½œç”¨å‡½æ•°å¼¹å‡ºæ ˆï¼Œå¹¶æŠŠ activeEffect å¤åŸå›ä¹‹å‰çš„å€¼
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];
    };
    effectFn.options = options;
    effectFn.deps = [];
    effectFn();
  }

  function cleanup(effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
      const deps = effectFn.deps[i];
      deps.delete(effectFn);
    }

    effectFn.deps.length = 0;
  }

  // é˜²æŠ–
  const jobQueue = new Set();
  const p = Promise.resolve();

  let isFlushing = false;
  function flushJob() {
    if (isFlushing) return;
    isFlushing = true;

    p.then(() => {
      jobQueue.forEach(job => job());
    }).finally(() => {
      isFlushing = false;
    });
  }

  effect(
    () => {
      console.log(obj.foo);
    },
    {
      scheduler(fn) {
        jobQueue.add(fn);
        flushJob();
      }
    }
  );

  // è¿ç»­è§¦å‘
  obj.foo++;
  obj.foo++;
  obj.foo++;
  obj.foo++;
  obj.foo++;
  obj.foo++;
  obj.foo++;
</script> -->

<!-- <script>
  // 8

  // å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶
  const bucket = new WeakMap();

  // åŸå§‹æ•°æ®
  const data = { foo: 1, bar: 2 };

  // å¯¹åŸå§‹æ•°æ®çš„ä»£ç†
  const obj = new Proxy(data, {
    // æ‹¦æˆªè¯»å–æ“ä½œ
    get(target, key) {
      // å°†å‰¯ä½œç”¨å‡½æ•° activeEffect æ·»åŠ åˆ°å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶ä¸­
      track(target, key);
      // è¿”å›å±æ€§å€¼
      return target[key];
    },
    // æ‹¦æˆªè®¾ç½®æ“ä½œ
    set(target, key, newVal) {
      // è®¾ç½®å±æ€§å€¼
      target[key] = newVal;
      // æŠŠå‰¯ä½œç”¨å‡½æ•°ä»æ¡¶é‡Œå–å‡ºå¹¶æ‰§è¡Œ
      trigger(target, key);
    }
  });

  // åœ¨ get å†…éƒ¨è·Ÿè¸ªå˜åŒ–
  function track(target, key) {
    if (!activeEffect) return ;

    // æ ¹æ® target ä»â€œæ¡¶â€ä¸­å–çš„ depsMapï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª Map ç±»å‹ï¼š key -> effects
    let depsMap = bucket.get(target);
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()));
    }

    // å†æ ¹æ® key ä» depsMap ä¸­å–å¾— depsï¼Œå®ƒæ˜¯ä¸€ä¸ª Set ç±»å‹
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }

    // æœ€åå°†å½“å‰æ¿€æ´»çš„å‡½æ•°æ·»åŠ åˆ°â€œæ¡¶â€ä¸­
    deps.add(activeEffect);

    // å°†å…¶æ·»åŠ åˆ° activeEffect.deps æ•°ç»„ä¸­
    activeEffect.deps.push(deps);
  }

  // åœ¨ set å†…éƒ¨è§¦å‘å˜åŒ–
  function trigger(target, key) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;

    const effects = depsMap.get(key);

    const effectsToRun = new Set();

    effects.forEach(effectFn => {
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn);
      }
    });

    effectsToRun.forEach(effectFn => {
      if (effectFn.options.scheduler) {
        effectFn.options.scheduler(effectFn);
      } else {
        effectFn();
      }
    });
  }

  // ç”¨ä¸€ä¸ªå…¨å±€å˜é‡å­˜æ”¾è¢«æ³¨å†Œçš„å‰¯ä½œç”¨å‡½æ•°
  let activeEffect;
  // å‰¯ä½œç”¨å‡½æ•°æ ˆ
  const effectStack = [];
  // effect ç”¨æ¥æ³¨å†Œå‰¯ä½œç”¨å‡½æ•°
  function effect(fn, options = {}) {
    const effectFn = () => {
      cleanup(effectFn);
      // ä¿å­˜å‰¯ä½œç”¨å‡½æ•°
      activeEffect = effectFn;
      // å…¥æ ˆ
      effectStack.push(effectFn);
      const res = fn();
      // å½“å‰å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œå°†å½“å‰å‰¯ä½œç”¨å‡½æ•°å¼¹å‡ºæ ˆï¼Œå¹¶æŠŠ activeEffect å¤åŸå›ä¹‹å‰çš„å€¼
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];

      return res;
    };

    effectFn.options = options;
    effectFn.deps = [];
    if (!options.lazy) {
      effectFn();
    }

    return effectFn;
  }

  function cleanup(effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
      const deps = effectFn.deps[i];
      deps.delete(effectFn);
    }

    effectFn.deps.length = 0;
  }

  // é˜²æŠ–
  const jobQueue = new Set();
  const p = Promise.resolve();

  let isFlushing = false;
  function flushJob() {
    if (isFlushing) return;
    isFlushing = true;

    p.then(() => {
      jobQueue.forEach(job => job());
    }).finally(() => {
      isFlushing = false;
    });
  }

  let effectFn = effect(
    () => {
      console.log(obj.foo);
    },
    {
      lazy: true,
      scheduler(fn) {
        jobQueue.add(fn);
        flushJob();
      }
    }
  );

  function computed(getter) {
    let value;
    let dirty = true;

    const effectFn = effect(getter, {
      lazy: true,
      scheduler() {
        if (!dirty) {
          dirty = true;
          trigger(obj, 'value');
        }
      }
    });

    const obj = {
      get value() {
        if (dirty) {
          value = effectFn();
          dirty = false;
        }
        track(obj, 'value');
        return value;
      }
    };

    return obj;
  }

  const sumRes = computed(() => obj.foo + obj.bar);

  console.log(sumRes.value);
  console.log(sumRes.value);

  obj.foo++;

  console.log(sumRes.value);

  effect(() => {
    console.log(sumRes.value);
  });

  obj.foo++;
</script> -->

<!-- <script>
  // 9

  // å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶
  const bucket = new WeakMap();

  // åŸå§‹æ•°æ®
  const data = { foo: 1, bar: 2 };

  // å¯¹åŸå§‹æ•°æ®çš„ä»£ç†
  const obj = new Proxy(data, {
    // æ‹¦æˆªè¯»å–æ“ä½œ
    get(target, key) {
      // å°†å‰¯ä½œç”¨å‡½æ•° activeEffect æ·»åŠ åˆ°å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶ä¸­
      track(target, key);
      // è¿”å›å±æ€§å€¼
      return target[key];
    },
    // æ‹¦æˆªè®¾ç½®æ“ä½œ
    set(target, key, newVal) {
      // è®¾ç½®å±æ€§å€¼
      target[key] = newVal;
      // æŠŠå‰¯ä½œç”¨å‡½æ•°ä»æ¡¶é‡Œå–å‡ºå¹¶æ‰§è¡Œ
      trigger(target, key);
    }
  });

  // åœ¨ get å†…éƒ¨è·Ÿè¸ªå˜åŒ–
  function track(target, key) {
    if (!activeEffect) return;

    // æ ¹æ® target ä»â€œæ¡¶â€ä¸­å–çš„ depsMapï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª Map ç±»å‹ï¼š key -> effects
    let depsMap = bucket.get(target);
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()));
    }

    // å†æ ¹æ® key ä» depsMap ä¸­å–å¾— depsï¼Œå®ƒæ˜¯ä¸€ä¸ª Set ç±»å‹
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }

    // æœ€åå°†å½“å‰æ¿€æ´»çš„å‡½æ•°æ·»åŠ åˆ°â€œæ¡¶â€ä¸­
    deps.add(activeEffect);

    // å°†å…¶æ·»åŠ åˆ° activeEffect.deps æ•°ç»„ä¸­
    activeEffect.deps.push(deps);
  }

  // åœ¨ set å†…éƒ¨è§¦å‘å˜åŒ–
  function trigger(target, key) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;

    const effects = depsMap.get(key);

    const effectsToRun = new Set();

    effects.forEach(effectFn => {
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn);
      }
    });

    effectsToRun.forEach(effectFn => {
      if (effectFn.options.scheduler) {
        effectFn.options.scheduler(effectFn);
      } else {
        effectFn();
      }
    });
  }

  // ç”¨ä¸€ä¸ªå…¨å±€å˜é‡å­˜æ”¾è¢«æ³¨å†Œçš„å‰¯ä½œç”¨å‡½æ•°
  let activeEffect;
  // å‰¯ä½œç”¨å‡½æ•°æ ˆ
  const effectStack = [];
  // effect ç”¨æ¥æ³¨å†Œå‰¯ä½œç”¨å‡½æ•°
  function effect(fn, options = {}) {
    const effectFn = () => {
      cleanup(effectFn);
      // ä¿å­˜å‰¯ä½œç”¨å‡½æ•°
      activeEffect = effectFn;
      // å…¥æ ˆ
      effectStack.push(effectFn);
      const res = fn();
      // å½“å‰å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œå°†å½“å‰å‰¯ä½œç”¨å‡½æ•°å¼¹å‡ºæ ˆï¼Œå¹¶æŠŠ activeEffect å¤åŸå›ä¹‹å‰çš„å€¼
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];

      return res;
    };

    effectFn.options = options;
    effectFn.deps = [];
    if (!options.lazy) {
      effectFn();
    }

    return effectFn;
  }

  function cleanup(effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
      const deps = effectFn.deps[i];
      deps.delete(effectFn);
    }

    effectFn.deps.length = 0;
  }

  function traverse(value, seen = new Set()) {
    if (typeof value !== 'object' || value === null || seen.has(value)) return;

    seen.add(value);

    for (const k in value) {
      // è¯»å–å¯¹è±¡æ¯ä¸€ä¸ªå€¼ï¼Œå¹¶ä¸”é€’å½’è°ƒç”¨
      traverse(value[k], seen);
    }

    return value;
  }

  function watch(source, cd) {
    let getter;

    if (typeof source === 'function') {
      getter = source;
    } else {
      getter = () => traverse(source);
    }

    let oldValue, newValue;

    const effectFn = effect(() => getter(), {
      lazy: true,
      scheduler() {
        newValue = effectFn();
        cd(oldValue, newValue);
        oldValue = newValue;
      }
    });

    oldValue = effectFn();
  }

  watch(
    () => obj.foo,
    (oldValue, newValue) => {
    }
  );

  obj.foo++;
</script> -->

<script>
  // 10
  // å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶
  const bucket = new WeakMap();

  // åŸå§‹æ•°æ®
  const data = { foo: 1, bar: 2 };

  // å¯¹åŸå§‹æ•°æ®çš„ä»£ç†
  const obj = new Proxy(data, {
    // æ‹¦æˆªè¯»å–æ“ä½œ
    get(target, key) {
      // å°†å‰¯ä½œç”¨å‡½æ•° activeEffect æ·»åŠ åˆ°å­˜å‚¨å‰¯ä½œç”¨å‡½æ•°çš„æ¡¶ä¸­
      track(target, key);
      // è¿”å›å±æ€§å€¼
      return target[key];
    },
    // æ‹¦æˆªè®¾ç½®æ“ä½œ
    set(target, key, newVal) {
      // è®¾ç½®å±æ€§å€¼
      target[key] = newVal;
      // æŠŠå‰¯ä½œç”¨å‡½æ•°ä»æ¡¶é‡Œå–å‡ºå¹¶æ‰§è¡Œ
      trigger(target, key);
    }
  });

  // åœ¨ get å†…éƒ¨è·Ÿè¸ªå˜åŒ–
  function track(target, key) {
    if (!activeEffect) return;

    // æ ¹æ® target ä»â€œæ¡¶â€ä¸­å–çš„ depsMapï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ª Map ç±»å‹ï¼š key -> effects
    let depsMap = bucket.get(target);
    if (!depsMap) {
      bucket.set(target, (depsMap = new Map()));
    }

    // å†æ ¹æ® key ä» depsMap ä¸­å–å¾— depsï¼Œå®ƒæ˜¯ä¸€ä¸ª Set ç±»å‹
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }

    // æœ€åå°†å½“å‰æ¿€æ´»çš„å‡½æ•°æ·»åŠ åˆ°â€œæ¡¶â€ä¸­
    deps.add(activeEffect);

    // å°†å…¶æ·»åŠ åˆ° activeEffect.deps æ•°ç»„ä¸­
    activeEffect.deps.push(deps);
  }

  // åœ¨ set å†…éƒ¨è§¦å‘å˜åŒ–
  function trigger(target, key) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;

    const effects = depsMap.get(key);

    const effectsToRun = new Set();

    effects.forEach(effectFn => {
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn);
      }
    });

    effectsToRun.forEach(effectFn => {
      if (effectFn.options.scheduler) {
        effectFn.options.scheduler(effectFn);
      } else {
        effectFn();
      }
    });
  }

  // ç”¨ä¸€ä¸ªå…¨å±€å˜é‡å­˜æ”¾è¢«æ³¨å†Œçš„å‰¯ä½œç”¨å‡½æ•°
  let activeEffect;
  // å‰¯ä½œç”¨å‡½æ•°æ ˆ
  const effectStack = [];
  // effect ç”¨æ¥æ³¨å†Œå‰¯ä½œç”¨å‡½æ•°
  function effect(fn, options = {}) {
    const effectFn = () => {
      cleanup(effectFn);
      // ä¿å­˜å‰¯ä½œç”¨å‡½æ•°
      activeEffect = effectFn;
      // å…¥æ ˆ
      effectStack.push(effectFn);
      const res = fn();
      // å½“å‰å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œå°†å½“å‰å‰¯ä½œç”¨å‡½æ•°å¼¹å‡ºæ ˆï¼Œå¹¶æŠŠ activeEffect å¤åŸå›ä¹‹å‰çš„å€¼
      effectStack.pop();
      activeEffect = effectStack[effectStack.length - 1];

      return res;
    };

    effectFn.options = options;
    effectFn.deps = [];
    if (!options.lazy) {
      effectFn();
    }

    return effectFn;
  }

  function cleanup(effectFn) {
    for (let i = 0; i < effectFn.deps.length; i++) {
      const deps = effectFn.deps[i];
      deps.delete(effectFn);
    }

    effectFn.deps.length = 0;
  }

  function traverse(value, seen = new Set()) {
    if (typeof value !== 'object' || value === null || seen.has(value)) return;

    seen.add(value);

    for (const k in value) {
      // è¯»å–å¯¹è±¡æ¯ä¸€ä¸ªå€¼ï¼Œå¹¶ä¸”é€’å½’è°ƒç”¨
      traverse(value[k], seen);
    }

    return value;
  }

  function watch(source, cd, options = {}) {
    let getter;

    if (typeof source === 'function') {
      getter = source;
    } else {
      getter = () => traverse(source);
    }

    let oldValue, newValue;

    let cleanup;

    function onInvalidate(fn) {
      cleanup = fn;
    }

    const job = () => {
      newValue = effectFn();
      if (cleanup) {
        cleanup();
      }
      cd(oldValue, newValue, onInvalidate);
      oldValue = newValue;
    };

    const effectFn = effect(() => getter(), {
      lazy: true,
      scheduler: () => {
        if (options.flush === 'post') {
          const p = Promise.resolve();
          p.then(job);
        } else {
          job();
        }
      }
    });

    if (options.immediate) {
      job();
    } else {
      oldValue = effectFn();
    }
  }

  watch(
    () => obj,
    async (oldValue, newValue, onInvalidate) => {
      console.log('ğŸš€  -> file: index.html -> line 1084 -> newValue', newValue);
      let expored = false;

      onInvalidate(() => {
        expored = true;
      });

      const res = await fetch('./04.å“åº”ç³»ç»Ÿçš„ä½œç”¨ä¸å®ç°.md');
      
      if (!expored) {
        finalData = res;
      }
    }
  );
  obj.foo++;
</script>
