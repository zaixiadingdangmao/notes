## 03.语言基础

- [03.语言基础](#03语言基础)
  - [变量](#变量)
    - [var 关键字](#var-关键字)
    - [let 声明](#let-声明)
    - [const 声明](#const-声明)
    - [通过 const 和 let 声明提升性能](#通过-const-和-let-声明提升性能)
  - [数据类型](#数据类型)
    - [typeof 操作符](#typeof-操作符)
    - [Undefined 类型](#undefined-类型)
    - [Null 类型](#null-类型)
    - [Boolean 类型](#boolean-类型)
    - [Number 类型](#number-类型)
    - [String 类型](#string-类型)
    - [Symbol 类型](#symbol-类型)
    - [Object 类型](#object-类型)
  - [操作符](#操作符)
    - [按位非](#按位非)
    - [符号位移](#符号位移)
    - [指数操作符](#指数操作符)
    - [关系操作符](#关系操作符)
    - [相等操作符](#相等操作符)
    - [逗号操作符](#逗号操作符)
    - [do-while 语句](#do-while-语句)
    - [for-in 语句](#for-in-语句)
    - [for-of 语句](#for-of-语句)
    - [break 和 continue 语句](#break-和-continue-语句)
    - [switch 语句](#switch-语句)
  - [小结](#小结)
    - [ECMAScript 中的基本元素](#ecmascript-中的基本元素)
    - [ECMAScript 中的函数与其他语言中的函数不一样。](#ecmascript-中的函数与其他语言中的函数不一样)

### 变量

#### var 关键字

使用这个关键字声明的变量会自动提升到函数作用域顶部

#### let 声明

`let` 跟 `var` 的作用差不多，但有着非常重要的区别。最明显的区别是，`let` 声明的范围是块作用域，而 `var` 声明的范围是函数作用域

- 暂时性死区
  `let` 与 `var` 的另一个重要的区别，就是 `let` 声明的变量不会在作用域中被提升，在 `let` 声明之前的执行瞬间被称为“暂时性死区”

#### const 声明

> 由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。

`const` 的行为与 `let` 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 `const` 声明的变量会导致运行时错误
`const` 声明的限制只适用于它指向的变量的引用。换句话说，如果 `const` 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 `const` 的限制

#### 通过 const 和 let 声明提升性能

ES6 增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为 `const` 和 `let` 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生

### 数据类型

#### typeof 操作符

调用 `typeof null` 返回的是 `object`。这是因为特殊值 `null` 被认为是一个对空对象的引用

#### Undefined 类型

`Undefined` 类型只有一个值，就是特殊值 `undefined。当使用` `var` 或 `let` 声明了变量但没有初始化时，就相当于给变量赋予了 `undefined` 值

> 对未声明的变量，只能执行一个有用的操作，就是对它调用 typeof

#### Null 类型

`Null` 类型同样只有一个值，即特殊值 `null`。逻辑上讲，`null` 值表示一个空对象指针，这也是给 `typeof` 传一个 `null` 会返回 `object` 的原因

#### Boolean 类型

`Boolean`（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：`true` 和 `false`。这两个布尔值不同于数值，因此 `true` 不等于 1，`false` 不等于 0

#### Number 类型

- 浮点值
  因为存储浮点值使用的内存空间是**存储整数值的两倍**，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数

#### String 类型

String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（"）、单引号（'）或反引号（`）标示

- 模板字面量
  ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，**模板字面量保留换行字符**

#### Symbol 类型

Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险

#### Object 类型

ECMAScript 中的对象其实就是一组数据和功能的集合

### 操作符

#### 按位非 ~

按位非操作符用波浪符（~）表示，它的作用是返回数值的一补数，按位非的最终效果是对数值取反并减 1，实际上，尽管两者返回的结果一样，但位操作的速度快得多。这是因为位操作是在数值的底层表示上完成的。

#### 符号位移 >> <<

会按照指定的位数将数值的所有位向左移动
两个代表符号位移动 三个代表无符号位移

- ==左移动== `<<` `2 << 5 = 64` 相当于 $2*2^5$
- ==右移动== `>>` `64 >> 5 = 2`

#### 指数操作符

ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符\*\*，结果是一样的：

```js
console.log(Math.pow(3, 2);    // 9
console.log(3 ** 2);           // 9
console.log(Math.pow(16, 0.5); // 4
console.log(16** 0.5);         // 4
```

#### 关系操作符

使用关系操作符比较两个字符串时，会发生一个有趣的现象。很多人认为小于意味着“字母顺序靠前”，而大于意味着“字母顺序靠后”，实际上不是这么回事。**对字符串而言，关系操作符会比较字符串中对应字符的编码，而这些编码是数值**。比较完之后，会返回布尔值。问题的关键在于，大写字母的编码都小于小写字母的编码，因此以下这种情况就会发生

```js
'Brick' < 'alphabet'; // true
```

另一个奇怪的现象是在比较两个数值字符串的时候，比如下面这个例子：

```js
'23' < '3'; // true
'23' < 3; // false
```

> 只要是数值和字符串比较，字符串就会先被转换为数值，然后进行数值比较

#### 相等操作符

- ==等于和不等于== 这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。 如果操作数相等，则会返回 `true`

- ==全等和不全等== 全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。只有两个操作数在不转换的前提下相等才返回 `true`

#### 逗号操作符

逗号操作符可以用来在一条语句中执行多个操作，如下所示：

```js
let num1 = 1,
  num2 = 2,
  num3 = 3;
```

在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：

```js
let num = (5, 1, 4, 8, 0); // num的值为0
```

###　语句

#### do-while 语句

`do-while` 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次

#### for-in 语句

`for-in` 语句是一种严格的迭代语句，用于**枚举**对象中的非符号键属性，`for-in` 语句不能保证返回对象属性的顺序，所有**可枚举**的属性都会返回一次，但返回的顺序可能会因浏览器而异。

```js
for (const propName in window) {
  document.write(propName);
}
```

这个例子使用 `for-in` 循环显示了 `BOM` 对象 `window` 的所有属性。每次执行循环，都会给变量 `propName` 赋予一个 `window` 对象的属性作为值，直到 `window` 的所有属性都被枚举一遍。与 for 循环一样，这里控制语句中的 `const` 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 `const`

#### for-of 语句

`for-of` 语句是一种严格的迭代语句，用于遍历**可迭代对象**的元素
`for-of` 循环会按照**可迭代对象**的 `next()` 方法产生值的顺序迭代元素

#### break 和 continue 语句

`break` 语句用于立即退出循环，强制执行循环后的下一条语句。而 `continue` 语句也用于立即退出循环，但会再次从循环顶部开始执行

> `break` 退出循环 `continue` 退出本次循环

#### switch 语句

> switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串"10"不等于数值 10）

### 小结

#### ECMAScript 中的基本元素

- ECMAScript 中的基本数据类型包括 Undefined、Null、Boolean、Number、String 和 Symbol。
- 与其他语言不同，ECMAScript 不区分整数和浮点值，只有 Number 一种数值数据类型。
- Object 是一种复杂数据类型，它是这门语言中所有对象的基类。
- 严格模式为这门语言中某些容易出错的部分施加了限制。
- ECMAScript 提供了 C 语言和类 C 语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。
- 这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如 if 语句、for 语句和 switch 语句等。

#### ECMAScript 中的函数与其他语言中的函数不一样。

- 不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。
- 不指定返回值的函数实际上会返回特殊值 undefined。
